<!DOCTYPE html>
<html>
  <head>
  <title></title>
  
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no;" />
	<meta charset="utf-8">


	<!-- iPad/iPhone specific css below, add after your main css >
	<link rel="stylesheet" media="only screen and (max-device-width: 1024px)" href="ipad.css" type="text/css" />		
	<link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="iphone.css" type="text/css" />		
	-->
	<!-- If your application is targeting iOS BEFORE 4.0 you MUST put json2.js from http://www.JSON.org/json2.js into your www directory and include it here -->
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="css/farbtastic.css" type="text/css" />
        
    <script type="text/javascript" charset="utf-8" src="cordova-1.7.0.js"></script>
    <script src="js/processing.js" type="text/javascript"></script>
  	<script src="js/processing-twitter.js" type="text/javascript"></script>
    <!--<script type="text/javascript" src="js/colorpicker.js"></script>
    <script type="text/javascript" src="js/jscolor/jscolor.js"></script> !-->
        
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="js/farbtastic.js"></script>

        
    <script type="text/javascript">
	// If you want to prevent dragging, uncomment this section
	/*
	function preventBehavior(e) 
	{ 
      e.preventDefault(); 
    };
	document.addEventListener("touchmove", preventBehavior, false);
	*/
	
	/* If you are supporting your own protocol, the var invokeString will contain any arguments to the app launch.
	see http://iphonedevelopertips.com/cocoa/launching-your-own-application-via-a-custom-url-scheme.html
	for more details -jm */
	/*
	function handleOpenURL(url)
	{
		// TODO: do something with the url passed in.
	}
	*/
	
	function onBodyLoad()
	{		
		document.addEventListener("deviceready", onDeviceReady, false);
	}
        
    // turn off app when the back key is down
    function onDeviceReady(){
        document.addEventListener("backbutton",onBackKeyDown,true);
    }
        
	/* When this function is called, Cordova has been initialized and is ready to roll */
	/* If you are supporting your own protocol, the var invokeString will contain any arguments to the app launch.
	see http://iphonedevelopertips.com/cocoa/launching-your-own-application-via-a-custom-url-scheme.html
	for more details -jm */
	function onDeviceReady()
	{
		
       
	}
    /// INTERFACE FUNCTIONS
    var theOverlay;
    var theLoader;
    var theReadout;
    // show and hide
    // this is called from the canvas
    function showOverlay(theID){
        theOverlay = document.getElementById("interface");
        theOverlay.style.display = "block";

    }
    // this is called from the interface
    function hideOverlay(){
        if (!processingInstance) {
            processingInstance = Processing.getInstanceById('tweets');
        }
        theOverlay = document.getElementById("interface");
        theOverlay.style.display = "none";
        processingInstance.overlayOff();
    }
    
        
    function showLoader(){
        theReadout = document.getElementById("readout-style");
        theReadout.style.display = "none";
        
        theLoader = document.getElementById("loading-style");
        theLoader.style.display = "block";
        //processingInstance.overlayOff();
      
            
    }
    function hideLoader(){
        theLoader = document.getElementById("loading-style");
        theLoader.style.display = "none";
        
        theReadout = document.getElementById("readout-style");
        theReadout.style.display = "block";

    }
    ///////// DEVICE FUNCTIONS ////////

    function onBackKeyDown(){
        console.log("Hit Home Key");
        navigator.device.exitApp();
    }
        
    /// PROCESSING CONTROL FUNCTIONS ////
    var processingInstance;
    function testCom() {
      if (!processingInstance) {
          processingInstance = Processing.getInstanceById('tweets');
        }
           
           processingInstance.checkConsoleLog(); // stop animation, call noLoop()
      }
    
    /// speed slider
    function showValue(newValue){
    	/// document.getElementById("range").innerHTML=newValue;
    	processingInstance = Processing.getInstanceById('tweets');
    	processingInstance.changeAnimSpeed(newValue);
    	
    }
    /// animation change drop down
    function changeAnim(animType){
    	processingInstance = Processing.getInstanceById('tweets');
    	processingInstance.changeAnimationType(animType);
    	console.log("ACTIVATING ANIM CHANGE" + animType);
    	
    }
    /// search function
    function changeSearch(searchTerm){
        console.log("CHANGE SEARCH: " + searchTerm);
        processingInstance = Processing.getInstanceById('tweets');
    	processingInstance.initSearch(searchTerm);
      
    }
        /// toggle twitter pic
    function togglePic(toggleValue){
        console.log("TOGGLE PIC:  " + toggleValue);
        processingInstance = Processing.getInstanceById('tweets');
    	processingInstance.togglePic(toggleValue);

    }
    /// change background color
    function changeBGColor(hexColor){
        // console.log("INIT BG COLOR CHANGE:  " + hexColor);
         Processing.getInstanceById('tweets').changeBGColor(hexColor);    
    }
    function changeFontColor(hexColor){
        Processing.getInstanceById('tweets').changeFontColor(hexColor);
            
    }
        
    /// end PROCESSING CONTROL
        
        ////// CAMERA and PICTURE UPLOAD FUNCTIONS /////////////
        var pictureSource;   // picture source
        var destinationType; // sets the format of returned value
        
        // Wait for Cordova to connect with the device
        //
        document.addEventListener("deviceready",onDeviceReady,false);
        
        // Cordova is ready to be used!
        //
        function onDeviceReady() {
            pictureSource=navigator.camera.PictureSourceType;
            destinationType=navigator.camera.DestinationType;
        }
        
        // Called when a photo is successfully retrieved
        //
        function onPhotoDataSuccess(imageData) {
            // Uncomment to view the base64 encoded image data
            // console.log(imageData);
            
            // Get image handle
            //
            var smallImage = document.getElementById('smallImage');
            
            // Unhide image elements
            //
            smallImage.style.display = 'block';
            
            // Show the captured photo
            // The inline CSS rules are used to resize the image
            //
            smallImage.src = "data:image/jpeg;base64," + imageData;
        }
        
        // Called when a photo is successfully retrieved
        //
        function onPhotoURISuccess(imageURI) {
            // Uncomment to view the image file URI
            console.log("SELECTED IMAGE: " + imageURI);
            
            // Get image handle
            //
            /*
             var largeImage = document.getElementById('largeImage');
             
             // show the image in a div tag
             // Unhide image elements
             
             largeImage.style.display = 'block';
             
             // Show the captured photo
             // The inline CSS rules are used to resize the image
             //
             largeImage.src = imageURI;
             
             */
            /// save to the processing skech
            processingInstance = Processing.getInstanceById('tweets');
            processingInstance.setBackgroundImage(imageURI);
        }
        
        // simple capture
        /*
         function capturePhoto() {
         // Take picture using device camera and retrieve image as base64-encoded string
         navigator.camera.getPicture(onPhotoDataSuccess, onFail, { quality: 50,
         destinationType: destinationType.DATA_URL });
         }
         */
        /*
         function capturePhotoEdit() {
         // Take picture using device camera, allow edit, and retrieve image as base64-encoded string
         navigator.camera.getPicture(onPhotoDataSuccess, onFail, { quality: 20, allowEdit: true,
         destinationType: destinationType.DATA_URL });
         }
         */
        // GET PHOTO
        //
        function getPhoto(source) {
            // Retrieve image file location from specified source
            navigator.camera.getPicture(onPhotoURISuccess, onFail, { quality: 50,
                                        destinationType: destinationType.FILE_URI,
                                        sourceType: source });
        }
        
        // FAIL FUNCTIONS.
        //
        function onFail(message) {
            alert('Failed because: ' + message);
        }
        
        /// DELETE BACKGROUND IMAGE
        function deletePhoto(){
            
            processingInstance = Processing.getInstanceById('tweets');
            processingInstance.deleteBackgroundImage();
            
            
        }
    
    </script>
        
    <!-- COLOR PICKER CODE !-->
        
    <script type="text/javascript" charset="utf-8">
        $(document).ready(function() {
                        $('#color_picker').hide();
                        var f = $.farbtastic('#picker');
                        var p = $('#picker');
                        var selected;
                        $('.colorwell')
                        .each(function () { f.linkTo(this); $(this).css('opacity', 0.75); })
                        .focus(function() {
                                if (selected) {
                                     $(selected).css('opacity', 1).removeClass('colorwell-selected');
                                     }
                                     f.linkTo(this);
                                     p.css('opacity', 1);
                                     $(selected = this).css('opacity', 1).addClass('colorwell-selected');
                                     });
                        });
    </script>

        
  </head>
  <body onLoad="onBodyLoad()">
  <!--
  A port of http://blog.blprnt.com/blog/blprnt/updated-quick-tutorial-processing-twitter by Jer Thorp's
  Processing Twitter demo. The twitter API is exposed to Processing.js via a JavaScript library. I
  built this for a demo today, it's not really production quality, but could be refined to be used 
  as such.  Click the sketch to have the word list reload from fresh tweets.
  -->
  <script id='sketch' type="application/processing">
     
      ArrayList<String> words = new ArrayList();

      // Global ArrayList of tweets is created in processing-twitter.js
      // ArrayList<Tweet> tweets = new ArrayList();

      // A class representing a Tweet.  Tweet objects are created in JS
      // and automatically placed in the tweets ArrayList (created in JS)
      
      /// GLOBAL PROPERTIES
      int tWidth = 1024;  /// canvas width
      int tHeight = 768;  /// canvas height
      color bgColor = #000000;
      color tFontColor = #FFFFFF;
	  int tAnimSpeed = 2;
      int fadeSpeed;
	  int totalNumTweets;
      
      boolean hasTweets = false;
      
      boolean interfaceShowing = true;
      
      boolean showPic = true;
      
      string searchTerm;
      
      // Dynamic list of Tweet objects
      /// this holds our images
      HashMap uniqueTweets;
      //// text object
      ArrayList<TextSpawn> TextObjectArray;// =  new ArrayList();
      // each objects size is stored in an array
      
      
      // for some reason Processing wants to reset the text sizes
      /// I think I can get rid of this
      int[] TextSizes;
      int[] TextPosY;
      float oldLineHeight;
      float newLineHeight;
      
      int curTextID; /// id for texxt object to be faded

 	/// FONTS
      PFont BasicFont = createFont("Arial", 24, true);
      PFont ItalicFont = createFont("Arial Italic", 18, true);
      PFont SanSerif;
      PFont fontOne;
      PFont fontTwo;

      // IMAGES
      // PImage tweetPic;
      PImage bgroundImage;
      boolean showBGImage = false;
      /// ANIMATION PRESETS
      // scroll
      int tBoxSpace = 400; /// this is the spacing between scrolling tweet objects
      int tweetTextSize = 24;
	  string animationType = "fade"; // "fade", "wipeleft", "wiperight", "random"
	  boolean fadeOutReady = false;
	  int vertScrollHeight; // height of all the vertically scrolling tweets
      int theMargin = 50; // margins from side to side
      int charWidth = 10; // width of the text characters
      
    class Tweet {
      public String id;
      public String profileName;
      public String profileImageUrl;
      public PImage profileImage; // needs to be loaded manually
      public String text;
      public Date time;
    }

    void setup() {
        
      searchTerm = "#coachella";
      // XXX: jbuck: "just subtract 10"
	  size(1024, 768);
        
      // hash map that holds our tweets and images
      uniqueTweets = new HashMap();
        
      colorMode(RGB, 100);
      /// size(window.innerWidth, window.innerHeight-10);
      background(bgColor);
      smooth();

      // Slow things down a bit...
      frameRate(30);

               
       initSearch(searchTerm);
        
    }
      
      void initSearch(string tSearch){
          // zero out everything
          searchTerm = tSearch;
          try{
              // tweets.clear();
              curTextID = 0;
              // hash map that holds our tweet objects and images
              uniqueTweets = new HashMap();
              // text object array that holds all the text objects
              
              TextObjectArray =  new ArrayList();
              // set text sizes, pre-populate the array
              /// I don't think we need this anymore
              TextSizes = new int[100];
              TextPosY = new int[100];
              TextSizes[0] = tweetTextSize;

          } catch (e:Error){
              
              console.log("Can't reset tweets: " + e);
          }
          /// show the loading function
          showLoader();
          
          // Start a live feed loading, results will be available in a global
          // ArrayList called tweets.  loadTweets() is a custom method added
          // by processing-twitter.js
          loadTweets(searchTerm);
          
          // You can also pass geolocation data to limit tweets to a geographic area
          // loadTweets('class', '43.7496,-79.4886,1km'); // York University
          spawnText();

          
      }
      
      /// does the initial spawn
      void spawnText(){
          
          /*
          String[] fontList = PFont.list();
          console.log(fontList);
           */
          int prevBoxH = 0;
          int totalBoxH = 0;
          
          // If we haven't created the text objects, do it now
          if (tweets.size() > 0){
              console.log("spawn text objects: " + tweets.size());
              for (int i = 0; i < tweets.size(); i++) {
			
              Tweet t = (Tweet) tweets.get(i);
              /// get tweet data
              String msg = t.text;
              String usrName = t.profileName;
			  String theDate = t.date;
              String theImagePath = t.profileImageUrl;
              console.log("Name: " + t.profileName);
              
              // set profile image into tweet object by
              // loading a PImage of the profile pic
              // this may be the canvas taint workaround
              t.profileImage = requestImage(t.profileImageUrl);
              // save tweet object to our hashmap list of unique tweets
              uniqueTweets.put(t.id, t);

              //// ADD TEXT SPAWN
              theTextObject = new TextObject();
              TextSizes[i] = tweetTextSize;

              /// initialize our text object
              theTextObject.initText(msg, usrName, theImagePath, theDate, TextSizes[i], t.id);
              TextObjectArray.add(theTextObject);
              /// space the objects with v spacing + the line height

              theTextObject.theY = ((i*tBoxSpace) + prevBoxH) - tBoxSpace;
              console.log("PREV BOX HEIGHT = " + prevBoxH);
              prevBoxH = theTextObject.textBoxH;
              totalBoxH += prevBoxH;
              vertScrollHeight = (tweets.size()*tBoxSpace);//  + totalBoxH;

              // theTextObject.theY = (i * 200)-200; /// start spawning above 0 so there's no gap
          }
          /// get the total height of all the tweets for scrolling positioning
          console.log("TOTAL TWEETS: " + tweets.size() + "TOTAL BOX HEIGHT = " + vertScrollHeight + " JUST SPACING: "  + tweets.size()*tBoxSpace);

          totalNumTweets =  tweets.size();
          tweets.clear(); /// why do we want to clear the tweets after this?
		  hasTweets = true;
          hideLoader();

          }
          
      }

    void draw() {
        background(bgColor);
        // CHECK FOR BG IMAGE
        /// DO THE BGROUND IMAGE
        if(showBGImage){
            
            image(bgroundImage, 0, 0);
        }
        
         // CHECK FOR TWITTER DATA
        // if none, spawn the text object
        if (!hasTweets) {
            spawnText(); 
        }

		doTextObjectAnim();
       
    }

       //// INTERFACE FUNCTIONS
    
    // show or hide interface
      // Rebuild the word list when the user clicks
      
      void mousePressed() {
          // background(0);
          // tweets.clear();
          // words.clear();
          overlayOn();
      }
      void overlayOn(){
          /// show overlay
          window.showOverlay(); /// calls to the interface div in the htmls
          interfaceShowing = true; /// 
      }
      void overlayOff(){

          interfaceShowing = false;
          
      }
      
      void showLoader(){
          
          window.showLoader();
      }
      void hideLoader(){
          
          window.hideLoader();
      }
      
      /// change background colors

      void changeBGColor(String theColor){
          if(interfaceShowing){
              string dColor = theColor.substring(1);
              color hi = unhex("FF" + dColor);
              bgColor = hi;
          }
          
      }
      //// BACKGROUND IMAGE FUNCTIONS /////
      void setBackgroundImage(String imagePath){
          console.log("Processing has image: " + imagePath);
          
          String bgPath = imagePath;
          // Load image from the ipad
          try{
              bgroundImage = new PImage;
              bgroundImage = loadImage(bgPath);
              showBGImage = true;
          } catch (Exception e){
              
              console.log("CAN'T LOAD IMAGE: " + e);
          }
          
          
      }
      void deleteBackgroundImage(){
          
          showBGImage = false;
          console.log("DELETE BG IMAGE: " + showBGImage);
          
          
      }

      //// change font color
      void changeFontColor(int theColor){
          if(interfaceShowing){
              string dColor = theColor.substring(1);
              color newColor = unhex("FF" + dColor);
              tFontColor = newColor;
          }
         
      }
	  // change speed
	  void changeAnimSpeed(String newValue){
          if(interfaceShowing){
              int dAnim = int(newValue);
              tAnimSpeed = dAnim;
              /// reset everything and fade out with new speed
              
              //*
              TextObject dTextObj = TextObjectArray.get(curTextID);

              // dTextObj.timer.stop();
              dTextObj.fadeIn = false;
              dTextObj.fadeHold = false;
              dTextObj.fadeOut = true;
            //*/
          }
		}
      
      void togglePic(){
          
          if(showPic){
              
              
              showPic = false;
          } else if(!showPic){
              showPic = true;
              
          }
      }
     
	  //// change animation type
      void changeAnimationType(String animType){
		animationType = animType;
          reSetTextObjectFade();
		// console.log("SWITCH animationType CASE");
	  }

      void doTextObjectAnim(){
		// animationType = tType;
        switch(animationType) {
  		case 'fade':
            // reSetTextObjectFade();
    		setTextObjectFade();
    		break;
  		case 'scroll': 
			setTextObjectScroll();
    		break;
  		case 'wipe': 
    		println("wipe");  // Prints "Bravo"
    		break;
 		 default:
    		break;
		}
      }
	
	///// SET ALL TEXT OBJECT ANIMATION //////
	public void setTextObjectFade(){
 		for (int i = 0; i < TextObjectArray.size(); i++){
            try{
                
                // update text object
                // if it hasn't faded in and out,
                // init fade in toggle
                TextObject dTextObj = TextObjectArray.get(i);
                if(i == curTextID){
					// console.log("FADING: " + curTextID);

					// init fade
					if(!dTextObj.hasFaded){
						dTextObj.fadeIn = true;
					}
                	dTextObj.doFade();
				} 
                
            } catch (Exception:e){
                println("Can't find object for fade: " + e);
            }
        }	
	}
      
      /// RESET TEXT OBJECT FADE
      public void reSetTextObjectFade(){
          curTextID = 0;
          console.log("RESET FADE: " + TextObjectArray.size());
          for (int i = 0; i < TextObjectArray.size(); i++){
              
              try{
                  
                  // update text object
                  // if it hasn't faded in and out,
                  // init fade in toggle
                  TextObject dTextObj = TextObjectArray.get(i);
                  dTextObj.hasFaded = true;
                  dTextObj.fadeIn = false;
                  dTextObj.fadeHold = false;
                  dTextObj.fadeOut = false;
                  
              } catch (Exception:e){
                  println("Can't find object to reset fade: " + e);
              }
          }	
      }


	public void setTextObjectScroll(){
		for (int i = 0; i < TextObjectArray.size(); i++){
            try{
                // update text object position
                TextObject dTextObj = TextObjectArray.get(i);
                dTextObj.doScrollAnim();
                
            } catch (Exception:e){
                println("can't find object for scroll" + e);
            }
        }

	}

	//// END SET ALL TEXT OBJECT ANIM /////
      
    ///// DEVICE FUNCTIONS
      // stop app when hit home
      
      // geolocation filter
      
      /// wifi checker
      
    ///// MESSAGING FUNCTIONS
        
      /// error message
        // on
        // off
      
      // help window
      
      // info window
      
    //// TEXT OBJECT /////////
      // /*
      class TextObject {
          String tweetText = "";
          String tweetName = "";
		  String tweetTime = "";
          // String tweetPicPath = "";
          int numChars;
          int totalCharWidth = 0;

          int tSize= 36; // text size
          // int tSpacing = 60; // single line spacing
          int tId; // id of the tweet
		  int fadeLevel = 255;
          color fadeColor = (0,0,0,fadeLevel);

		  // text box sizes
          int numLines;
          int lineHeight = 60; // height of a single line
          int textBoxW = tWidth - (theMargin*2); /// width of the textbox - the margin on each side
		  int textBoxH; // height of the textbox
          int picWidth = 60; // width of twitter pic
          int picAdjY = 11;

          //// TIMER
		  Timer timer;

          /// positioning
          // private int theX = 0;
          private int theY = 0;
          
		  /// fade states
		  boolean fadeIn = false; /// toggle for initial fade in
		  boolean fadeHold = false;      
		  boolean fadeOut = false;
		  boolean hasFaded = false;
     
          void initText(String theTweet, String theName, String theImagePath, String theDate, int theSize, int theID){
              tId = theID;
              String rawTweet = theTweet;
              tweetText = rawTweet.replace("\n", "");
              tweetText = trim(tweetText); /// get rid of whitespace
              tweetName = theName;
			  tweetTime = theDate;
              /// set the size
              int tSize= theSize;
              //
              numChars = theTweet.length();
              
              // calculate the total length by adding up
              // the width of all the characters
              for(int l=0; l<numChars; l++){
                  int charw = textWidth(theTweet.charAt(l));
                  totalCharWidth += charw;
                  
              }
              // find out how many lines of text there are
              // by dividing numchars*charwidth by textBoxW
              // numLines = round((totalCharWidth)/textBoxW);
              
              // do it by hand?
              if(totalCharWidth < 300){
                  
                  numLines = 0;
              }
              if(totalCharWidth >= 300 && totalCharWidth < (600)){
                  
                  numLines = 1;
              }
              
              if(totalCharWidth >= (600)){
                  numLines = 2;
                  
              }
              
              textBoxH = 60+((numLines)*60);
             
              // numLines = Math.round((charWidth*numChars)/textBoxW);
              // console.log("NUM LINES: " + numLines);
              console.log("String: " + theTweet);
              console.log("lines: " + numLines + " char width: " + totalCharWidth);
              
              
          }

		  /// DO FADE ANIMATION////////
		  public void doFade(){
			/// set position
              // update fade speed
              // map(value, start1, stop1, start2, stop2)
              fadeSpeed = map(tAnimSpeed, 0, 20, 20000, 500);
              
			 if(fadeIn){ //// fading in
				fadeLevel -=tAnimSpeed;
				if(fadeLevel < 0){
					hasFaded = true;
					fadeIn = false;
					fadeHold = true;
					fadeOut = false;
					/// start hold timer
					timer = new Timer(fadeSpeed);
					timer.start();
					// console.log("DONE FADE IN, HOLDING" + fadeHold + " " + tId + " "  + fadeOut);
				}
				

			} 
			if (fadeHold){  /// fadeHold
					/// check hold timer status
					/// if it's run out, fade out
 					if (timer.isFinished()) {
						fadeIn = false;
						fadeHold = false;
						fadeOut = true;
						// console.log("DONE HOLDING, FADING OUT");
					}


			}
			if (fadeOut){ //// fade out
				fadeLevel +=tAnimSpeed;
				if(fadeLevel >=255){
					// console.log("DONE FADING OUT");
					fadeIn = true;
					fadeHold = false;
					fadeOut = false;

					/// check to see if we've faded all of them
					/// then reset the fade id
                    
                    curTextID +=1;
                    console.log("Cur Tweet: " + curTextID + " total: " + totalNumTweets);
                    if(curTextID >= totalNumTweets){
						console.log("FADED ALL LOOPS< RESETTING: "  + curTextID + " total: " + totalNumTweets);
						curTextID = 0;
						
					}
					hasFaded = true;
				}


			}
              
              // do the "from" name
			  //// draw the text box
              fill(tFontColor);
 			  textAlign(CENTER);
              /// "from" text
              string headerText = tweetName + "   ..." + tweetTime;
              textFont(ItalicFont, tSize);
              text(tweetName + "   ..." + tweetTime, theMargin + picWidth, 300, textBoxW, textBoxH);
              // text(tweetName + "   ..." + tweetTime, 45 + thePadding, 300, textBoxW, textBoxH);
              /// draw the image
              
              
              if(showPic){
                  picWidth = 60;
              
                  try{
                      //half the screen width - half the text box width
                      int picPosX = round(1024/2) - round(textWidth(headerText)/2);
                      object t = uniqueTweets.get(tId); // get(tId);
                      image(t.profileImage, picPosX, 300 - picAdjY);
                  } catch(e:error){
                      console.log("can't find tweet object: ");
                  }
              } else {
                  picWidth = 0;
              }

              
              /// tweet text
			  textFont(BasicFont,tSize);
			  text(tweetText, 45, 300 + lineHeight, textBoxW, textBoxH);
              textWidth(1024);
              
              /// cover it up to fake a fade
              fadeColor = color(bgColor,fadeLevel);
              fill(fadeColor);
              rect(0,0,tWidth, tHeight);
              

              
              //tweetPicPath


		  }
          
          /// DO SCROLLING ANIMATION ////
          
          public void doScrollAnim(){
              // check size, alignment, color
              // tSize = xsize;
              textAlign(LEFT); //// left align so we can line up the pic with the person's name
              fill(tFontColor);
			  // text(s, 10, 10, 70, 80);
			  // text(tweetText, theX, theY);
              
              /// only render if it's in the viewable area
              if(theY > -tBoxSpace && theY < 800){

                  if(showPic){
                      picWidth = 60;
                      object t = uniqueTweets.get(tId); // get(tId);
                      // Draw the profile image
                      try{
                          image(t.profileImage, theMargin, theY - picAdjY);
                      } catch(e:error){
                        console.log("can't find tweet object: " + e);
                    }
                  } else {
                      picWidth = 0;
                  }

                  // do the "from" name
                  textFont(ItalicFont, tSize);
                  text(tweetName + "   ..." + tweetTime, theMargin + picWidth, theY, textBoxW, lineHeight);
                  // console.log("HEIGHT: " + tweetName + " " + textBoxH);
                  // set the main tweet text
                  textFont(BasicFont,tSize);
                  text(tweetText, theMargin, theY + lineHeight, textBoxW, textBoxH);
                  
                   // move
                  //// show text box
                  /*
                  fill(60,60,60,60);
                  rect(theMargin, theY, textBoxW, textBoxH);
                   */
              }
              theY += tAnimSpeed;
              if(theY >= vertScrollHeight - tBoxSpace){
                  
                  theY = 0 -(tBoxSpace);
              }
              
          }
          
      }
	  private void doWordWrap(String theText){
		// get the width to be filled ///////
		// figure out how many chars per width
		// count thru the chars till hit a the maxwidth
		// save a line of text and put it in the array list
		// keep going until all chars are reached

		// merge array list as string with line breaks


	  }
       // end text object ///////
      
   // TIMER CLASS ////////
class Timer {
 
  int savedTime; // When Timer started
  int totalTime; // How long Timer should last
  
  Timer(int tempTotalTime) {
    totalTime = tempTotalTime;
  }
  
  // Starting the timer
  void start() {
    // When the timer starts it stores the current time in milliseconds.
	console.log("STARTING TIMER");
    savedTime = millis(); 
  }
  
  // The function isFinished() returns true if 5,000 ms have passed. 
  // The work of the timer is farmed out to this method.
  boolean isFinished() { 
    // Check how much time has passed
    int passedTime = millis()- savedTime;
    if (passedTime > totalTime) {
      return true;
    } else {
      return false;
    }
   }
   
 }

      
      
  </script>
      <canvas id="tweets">
          <p>Please upgrade your browser to something newer, like <a href="http://chrome.google.com" target="_blank">Google Chrome</a></p>
      </canvas>

        <div id="interface">
            <!-- HEADER CONTAINER !-->
            <div id="header_container">
            
                <ul id="header_list">
                <li><a href="#"><img src="images/header.png" width="253" height="33"></a>
                </li>
                <li><img src="images/butt_search_term.png" width="175" height="23"><input type="search" name="twittersearch" size="73" onsearch="changeSearch(this.value)" />
                </li>
                <li>
                    <div id="readout-style">Tweets Found:</div>
                    <div id="loading-style"><img src="images/loading_anim.gif" width="35" height="35"></div>
                </li>
                <li style=" float:right"><a href="#" onClick="hideOverlay(); return false;"><img align="middle" src="images/butt_close.png" width="140" height="40"></a>
                </li>
                </ul>
                
            </div>
            
            <!-- CONFIG CONTAINER !-->
            <div id="config_container">
            <ul id="config_list">
               <!-- COLOR PICKER CODE !-->   
               <li>

               <div id="color_picker" style="color: red; font-size: 1.4em"></div>
               <form action="">
                   <div id="picker" style="float: left;"></div>
                   <div class="form-item" id="form-item">
                       <div class="label-style">Change Color:</div>
                       <!-- <img src="images/butt_fontocolor.png" width="121" height="23"><br> !-->
                       <input type="text" id="color1" name="color1" class="colorwell" value="#123456" readonly="true"/>
                   </div>
                   <br><br>
                   <div class="form-item" id="form-item">
                       <!-- <img src="images/butt_bgcolor.png" width="213" height="23" ><br> !-->
                       <input type="text" id="color2" name="color2" class="colorwell" value="#123456" readonly="true"/>
                   </div>
               </form>

            <!-- load picture code !-->
                   
            <li>
                <div class="label-style">Change Background Image:</div>
                <input type="text" class="simpleButton" value="Load Image" readonly="true" onClick="getPhoto(pictureSource.PHOTOLIBRARY); return false;"/><br><br>
                <input type="text" class="simpleButton" value="Delete Image" readonly="true"onClick="deletePhoto(); return false;"/>
                
            </li>
                   
            <!-- misc config code !-->
            <li>
            <div class="label-style">Speed:</div>
            <input type="range" class="speedslider" min="0" max="20" value="5" step="1" onchange="showValue(this.value)"/><<br>
            <div class="label-style">Animation Type:</div>
                <select id="animation" onchange="changeAnim(this.value)">
                    <optgroup selected="selected" label="Animation Type" value="fade">Fade</option>
                        <option value ="fade">Fade</option>
                        <option value ="scroll">Scroll</option>
                        <option value ="wipe" >Wipe</option>
                    </optgroup>
                </select>
                <br>
            <div class="label-style">Show Pic:</div>
            <input type="checkbox" class="show-pic-style" onchange="togglePic(this.value)"/>
            </li>

            </ul>
            </div>
            <!-- end interface !-->
        </div>
</html>
